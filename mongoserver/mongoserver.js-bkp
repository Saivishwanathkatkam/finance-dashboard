
const express = require('express');
const cors = require('cors');
const { MongoClient, ObjectId } = require('mongodb');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

// --- CONFIGURATION ---
const MONGO_URI = "mongodb://127.0.0.1:27017";
const DB_NAME = "fin_dash_db";
const JWT_SECRET = "a_secure_secret_key_for_jwt_that_should_be_in_env_vars";
const PORT = 3001;

let db;

const app = express();
app.use(cors());
app.use(express.json());

// --- DATABASE CONNECTION ---
async function connectToDatabase() {
  try {
    const client = new MongoClient(MONGO_URI);
    await client.connect();
    db = client.db(DB_NAME);
    console.log("Successfully connected to MongoDB.");
    // Create unique index for user emails
    await db.collection('users').createIndex({ email: 1 }, { unique: true });
  } catch (error) {
    console.error("Failed to connect to MongoDB", error);
    process.exit(1);
  }
}

// --- AUTH MIDDLEWARE ---
const authMiddleware = (req, res, next) => {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ message: 'Unauthorized: No token provided.' });
    }
    try {
        const token = authHeader.split(' ')[1];
        const payload = jwt.verify(token, JWT_SECRET);
        if (!payload.userId) {
            return res.status(401).json({ message: 'Unauthorized: Invalid token payload.' });
        }
        req.userId = payload.userId;
        next();
    } catch (error) {
        return res.status(401).json({ message: 'Unauthorized: Invalid token.' });
    }
};

// --- AUTH ROUTES ---
app.post('/api/auth/signup', async (req, res) => {
    try {
        const { email, password } = req.body;
        if (!email || !password) {
            return res.status(400).json({ message: 'Email and password are required.' });
        }
        
        const existingUser = await db.collection('users').findOne({ email });
        if (existingUser) {
            return res.status(409).json({ message: 'Email already registered.' });
        }

        const passwordHash = await bcrypt.hash(password, 10);
        const result = await db.collection('users').insertOne({ email, passwordHash });

        const token = jwt.sign({ userId: result.insertedId.toString() }, JWT_SECRET, { expiresIn: '1d' });
        res.status(201).json({ token });
    } catch (error) {
        res.status(500).json({ message: 'Server error during signup.' });
    }
});

app.post('/api/auth/login', async (req, res) => {
    try {
        const { email, password } = req.body;
        const user = await db.collection('users').findOne({ email });
        if (!user) {
            return res.status(401).json({ message: 'Invalid email or password.' });
        }

        const isPasswordValid = await bcrypt.compare(password, user.passwordHash);
        if (!isPasswordValid) {
            return res.status(401).json({ message: 'Invalid email or password.' });
        }

        const token = jwt.sign({ userId: user._id.toString() }, JWT_SECRET, { expiresIn: '1d' });
        res.status(200).json({ token });
    } catch (error) {
        res.status(500).json({ message: 'Server error during login.' });
    }
});

// === ALL DATA ROUTES PROTECTED ===
app.use('/api', authMiddleware);

// === INCOME ROUTES ===
app.get('/api/income', async (req, res) => {
    console.log("@@@@#31111111111111");
    const userId = new ObjectId(req.userId);
    const userRecords = await db.collection('income').find({ userId }).sort({ date: -1 }).toArray();
    res.status(200).json(userRecords);
});
app.post('/api/income', async (req, res) => {
	console.log("@@@@#31111111111111");
    const { date, source, category, amount, notes } = req.body;
    const newRecord = { userId: new ObjectId(req.userId), date: new Date(date), source, category, amount: parseFloat(amount), notes };
    const result = await db.collection('income').insertOne(newRecord);
    res.status(201).json({ _id: result.insertedId, ...newRecord });
});
app.put('/api/income/:id', async (req, res) => {
	console.log("@@@@#31111111111111");
    const { id } = req.params;
    const { _id, userId, ...updateData } = req.body;
    updateData.date = new Date(updateData.date); // Ensure date is Date object
    const result = await db.collection('income').updateOne({ _id: new ObjectId(id), userId: new ObjectId(req.userId) }, { $set: updateData });
    if(result.matchedCount === 0) return res.status(404).json({ message: 'Record not found.' });
    res.status(200).json({ _id: id, ...updateData });
});
app.delete('/api/income/:id', async (req, res) => {
	console.log("@@@@#31111111111111");
    const result = await db.collection('income').deleteOne({ _id: new ObjectId(req.params.id), userId: new ObjectId(req.userId) });
    if(result.deletedCount === 0) return res.status(404).json({ message: 'Record not found.' });
    res.status(204).send();
});

// === BANK ACCOUNT ROUTES ===
app.get('/api/bank-accounts', async (req, res) => {
	console.log("@@@@#31111111111111");
    const accounts = await db.collection('bankAccounts').find({ userId: new ObjectId(req.userId) }).toArray();
    res.status(200).json(accounts);
});
app.post('/api/bank-accounts', async (req, res) => {
	console.log("@@@@#31111111111111");
    const { accountName, accountNumber } = req.body;
    const newAccount = { userId: new ObjectId(req.userId), accountName, accountNumber, isActive: true };
    const result = await db.collection('bankAccounts').insertOne(newAccount);
    res.status(201).json({ _id: result.insertedId, ...newAccount });
});
app.delete('/api/bank-accounts/:id', async (req, res) => {
	console.log("@@@@#31111111111111");
    const accountId = new ObjectId(req.params.id);
    const userId = new ObjectId(req.userId);
    const deleteAccResult = await db.collection('bankAccounts').deleteOne({ _id: accountId, userId });
    if (deleteAccResult.deletedCount === 0) return res.status(404).json({ message: 'Account not found.' });
    await db.collection('bankTransactions').deleteMany({ accountId, userId });
    res.status(204).send();
});

// === BANK TRANSACTION ROUTES ===
app.get('/api/transactions', async (req, res) => {
    const { accountId } = req.query;
    const transactions = await db.collection('bankTransactions').find({ accountId: new ObjectId(accountId), userId: new ObjectId(req.userId) }).sort({ date: -1 }).toArray();
    res.status(200).json(transactions);
});
app.post('/api/transactions', async (req, res) => {
    const { accountId, ...transData } = req.body;
    transData.date = new Date(transData.date);
    const newTransaction = { ...transData, accountId: new ObjectId(accountId), userId: new ObjectId(req.userId) };
    const result = await db.collection('bankTransactions').insertOne(newTransaction);
    res.status(201).json({ _id: result.insertedId, ...newTransaction });
});
app.put('/api/transactions/:id', async (req, res) => {
    console.log("555555555555555");
    const { id } = req.params;
    const { _id, userId, accountId, ...updateData } = req.body;
    updateData.date = new Date(updateData.date);
    const result = await db.collection('bankTransactions').updateOne({ _id: new ObjectId(id), userId: new ObjectId(req.userId) }, { $set: updateData });
    if(result.matchedCount === 0) return res.status(404).json({ message: 'Transaction not found.'});
    res.status(200).json({ _id: id, ...updateData });
});
app.delete('/api/transactions/:id', async (req, res) => {
    const result = await db.collection('bankTransactions').deleteOne({ _id: new ObjectId(req.params.id), userId: new ObjectId(req.userId) });
    if(result.deletedCount === 0) return res.status(404).json({ message: 'Transaction not found.'});
    res.status(204).send();
});
app.post('/api/transactions/delete-by-date', async (req, res) => {
    const { accountId, dates } = req.body;
    const dateClauses = dates.map((isoDate) => {
        const startOfDay = new Date(isoDate);
        startOfDay.setUTCHours(0, 0, 0, 0);
        const endOfDay = new Date(startOfDay);
        endOfDay.setDate(endOfDay.getDate() + 1);
        return { date: { $gte: startOfDay, $lt: endOfDay } };
    });
    const result = await db.collection('bankTransactions').deleteMany({ accountId: new ObjectId(accountId), userId: new ObjectId(req.userId), source: 'CSV', $or: dateClauses });
    res.status(200).json({ success: true, deletedCount: result.deletedCount });
});
app.post('/api/transactions/bulk', async (req, res) => {
    console.log("555555555555555");
    const { accountId, transactions } = req.body;
    const userId = new ObjectId(req.userId);
    const newTransactions = transactions.map(t => ({ ...t, date: new Date(t.date), accountId: new ObjectId(accountId), userId }));
    const result = await db.collection('bankTransactions').insertMany(newTransactions);
    res.status(201).json({ insertedCount: result.insertedCount });
});
app.post('/api/transactions/bulk-delete', async (req, res) => {
    const { ids } = req.body;
    const objectIds = ids.map((id) => new ObjectId(id));
    const result = await db.collection('bankTransactions').deleteMany({ _id: { $in: objectIds }, userId: new ObjectId(req.userId) });
    res.status(200).json({ success: true, deletedCount: result.deletedCount });
});

// === INVESTMENTS ROUTES (Placeholder) ===
app.get('/api/investments', authMiddleware, (req, res) => res.status(501).json({ message: 'Not Implemented' }));
app.post('/api/investments', authMiddleware, (req, res) => res.status(501).json({ message: 'Not Implemented' }));

// --- START SERVER ---
connectToDatabase().then(() => {
    app.listen(PORT, () => {
        console.log(`Backend server running on http://localhost:${PORT}`);
    });
});

module.exports = app;
