
const express = require('express');
const cors = require('cors');
const { MongoClient, ObjectId } = require('mongodb');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const Papa = require("papaparse");

// --- CONFIGURATION ---
const MONGO_URI = "mongodb://127.0.0.1:27017";
const DB_NAME = "fin_dash_db";
const JWT_SECRET = "a_secure_secret_key_for_jwt_that_should_be_in_env_vars";
const PORT = 3001;

let db;

const app = express();
app.use(cors());
app.use(express.json());

// --- DATABASE CONNECTION ---
async function connectToDatabase() {
  try {
    const client = new MongoClient(MONGO_URI);
    await client.connect();
    db = client.db(DB_NAME);
    console.log("Successfully connected to MongoDB.");
    // Create unique index for user emails
    await db.collection('users').createIndex({ email: 1 }, { unique: true });
  } catch (error) {
    console.error("Failed to connect to MongoDB", error);
    process.exit(1);
  }
}

// --- CSV PARSING HELPER ---
// Note: This is a simple parser and may not handle complex CSVs (e.g., with quoted commas).
const parseCSV = (csvString) => {
    const lines = csvString.trim().replace(/\r\n/g, '\n').split('\n');
    if (lines.length < 2) return [];
    const headerLine = lines.shift();
    const headers = headerLine.split(',').map(h => h.trim());
    
    return lines.map(line => {
        const values = line.split(',');
        const entry = {};
        headers.forEach((header, index) => {
            entry[header] = values[index] ? values[index].trim() : '';
        });
        return entry;
    });
};


const parseTSVIncome = (fileData) => {
  return new Promise((resolve, reject) => {
    Papa.parse(fileData, {
      header: true,
      delimiter: "\t",          // TSV
      skipEmptyLines: "greedy",
      transformHeader: (h) => h.trim(),  // ðŸ‘ˆ VERY IMPORTANT
      complete: (results) => {

        const cleaned = [];

        for (const row of results.data) {
          if (!row || !row.date) continue;

          const parts = row.date.trim().split("-");
          if (parts.length !== 3) continue;

          const [day, month, year] = parts;
	  const monthobject = {"Jan": "1", "Feb": "2", "Mar": "3", "Apr": "4", "May": "5", "Jun": "6", "Jul": "7", "Aug": "8", "Sep": "9", "Oct": "10", "Nov": "11", "Dec": "12"};
	  let monthformat = monthobject[month];
          const date = new Date(year, monthformat - 1, day);

          if (isNaN(date.getTime())) continue;

          cleaned.push({
            date: date.toISOString(),
            source: row.source || "",
            category: row.category || "",
            amount: Number(row.amount.replace(",", "")),
          });
        }

	console.log(cleaned);
        resolve(cleaned);
      },
      error: reject,
    });
  });
};

const parseTSV = (fileData) => {
  return new Promise((resolve, reject) => {
    Papa.parse(fileData, {
      header: true,
      delimiter: "\t",          // TSV
      skipEmptyLines: "greedy",
      transformHeader: (h) => h.trim(),  // ðŸ‘ˆ VERY IMPORTANT
      complete: (results) => {
        console.log("Parsed sample row:", results.data[0]);

        const cleaned = [];

        for (const row of results.data) {
          if (!row || !row.Date) continue;

          const parts = row.Date.trim().split("/");
          if (parts.length !== 3) continue;

          const [day, month, year] = parts.map(Number);
          const date = new Date(year, month - 1, day);

          if (isNaN(date.getTime())) continue;

          cleaned.push({
            date: date.toISOString(),
            description: (row["Transaction Details"] || "").trim(),
            debit: Number(row.Debit) || 0,
            credit: Number(row.Credit) || 0,
            balance: Number(row.Balance) || 0,
          });
        }

        resolve(cleaned);
      },
      error: reject,
    });
  });
};

// --- AUTH MIDDLEWARE ---
const authMiddleware = (req, res, next) => {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ message: 'Unauthorized: No token provided.' });
    }
    try {
        const token = authHeader.split(' ')[1];
        const payload = jwt.verify(token, JWT_SECRET);
        if (!payload.userId) {
            return res.status(401).json({ message: 'Unauthorized: Invalid token payload.' });
        }
        req.userId = payload.userId;
        next();
    } catch (error) {
        return res.status(401).json({ message: 'Unauthorized: Invalid token.' });
    }
};

// --- AUTH ROUTES ---
app.post('/api/auth/signup', async (req, res) => {
    try {
        const { email, password } = req.body;
        if (!email || !password) {
            return res.status(400).json({ message: 'Email and password are required.' });
        }
        
        const existingUser = await db.collection('users').findOne({ email });
        if (existingUser) {
            return res.status(409).json({ message: 'Email already registered.' });
        }

        const passwordHash = await bcrypt.hash(password, 10);
        const result = await db.collection('users').insertOne({ email, passwordHash });

        const token = jwt.sign({ userId: result.insertedId.toString() }, JWT_SECRET, { expiresIn: '1d' });
        res.status(201).json({ token });
    } catch (error) {
        res.status(500).json({ message: 'Server error during signup.' });
    }
});

app.post('/api/auth/login', async (req, res) => {
    try {
        const { email, password } = req.body;
        const user = await db.collection('users').findOne({ email });
        if (!user) {
            return res.status(401).json({ message: 'Invalid email or password.' });
        }

        const isPasswordValid = await bcrypt.compare(password, user.passwordHash);
        if (!isPasswordValid) {
            return res.status(401).json({ message: 'Invalid email or password.' });
        }

        const token = jwt.sign({ userId: user._id.toString() }, JWT_SECRET, { expiresIn: '1d' });
        res.status(200).json({ token });
    } catch (error) {
        res.status(500).json({ message: 'Server error during login.' });
    }
});

// === ALL DATA ROUTES PROTECTED ===
app.use('/api', authMiddleware);

// === INCOME ROUTES ===
app.get('/api/income', async (req, res) => {
    const userId = new ObjectId(req.userId);
    const userRecords = await db.collection('income').find({ userId }).sort({ date: -1 }).toArray();
    res.status(200).json(userRecords);
});
app.post('/api/income', async (req, res) => {
    const { date, source, category, amount, notes } = req.body;
    const newRecord = { userId: new ObjectId(req.userId), date: new Date(date), source, category, amount: parseFloat(amount), notes };
    const result = await db.collection('income').insertOne(newRecord);
    res.status(201).json({ _id: result.insertedId, ...newRecord });
});
app.post('/api/income/upload', async (req, res) => {
    const { csv } = req.body;
    if (!csv) {
        return res.status(400).json({ message: 'CSV data is required.' });
    }
    try {
	console.log(csv);
        const parsedData = await parseTSVIncome(csv);
       
	console.log(parsedData);
        const newRecords = parsedData.map(row => ({
            userId: new ObjectId(req.userId),
            date: new Date(row.date),
            source: row.source,
            category: row.category,
            amount: row.amount,
            notes: row.notes || '',
        })).filter(r => !isNaN(r.date.getTime()) && r.source && r.amount);

	console.log(newRecords);
        if (newRecords.length === 0) {
            return res.status(400).json({ message: 'No valid records found in CSV.' });
        }

        const result = await db.collection('income').insertMany(newRecords);
        res.status(201).json({ insertedCount: result.insertedCount });

    } catch (error) {
        console.error("Error processing income CSV upload:", error);
        res.status(500).json({ message: 'Server error during CSV processing.' });
    }
});
app.put('/api/income/:id', async (req, res) => {
    const { id } = req.params;
    const { _id, userId, ...updateData } = req.body;
    updateData.date = new Date(updateData.date); // Ensure date is Date object
    const result = await db.collection('income').updateOne({ _id: new ObjectId(id), userId: new ObjectId(req.userId) }, { $set: updateData });
    if(result.matchedCount === 0) return res.status(404).json({ message: 'Record not found.' });
    res.status(200).json({ _id: id, ...updateData });
});
app.delete('/api/income/:id', async (req, res) => {
    const result = await db.collection('income').deleteOne({ _id: new ObjectId(req.params.id), userId: new ObjectId(req.userId) });
    if(result.deletedCount === 0) return res.status(404).json({ message: 'Record not found.' });
    res.status(204).send();
});

// === BANK ACCOUNT ROUTES ===
app.get('/api/bank-accounts', async (req, res) => {
    const accounts = await db.collection('bankAccounts').find({ userId: new ObjectId(req.userId) }).toArray();
    res.status(200).json(accounts);
});
app.post('/api/bank-accounts', async (req, res) => {
    const { accountName, accountNumber } = req.body;
    const newAccount = { userId: new ObjectId(req.userId), accountName, accountNumber, isActive: true };
    const result = await db.collection('bankAccounts').insertOne(newAccount);
    res.status(201).json({ _id: result.insertedId, ...newAccount });
});
app.delete('/api/bank-accounts/:id', async (req, res) => {
    const accountId = new ObjectId(req.params.id);
    const userId = new ObjectId(req.userId);
    const deleteAccResult = await db.collection('bankAccounts').deleteOne({ _id: accountId, userId });
    if (deleteAccResult.deletedCount === 0) return res.status(404).json({ message: 'Account not found.' });
    await db.collection('bankTransactions').deleteMany({ accountId, userId });
    res.status(204).send();
});

// === BANK TRANSACTION ROUTES ===
app.get('/api/transactions', async (req, res) => {
    const { accountId } = req.query;
    const transactions = await db.collection('bankTransactions').find({ accountId: new ObjectId(accountId), userId: new ObjectId(req.userId) }).sort({ date: -1 }).toArray();
    res.status(200).json(transactions);
});
app.post('/api/transactions', async (req, res) => {
    const { accountId, ...transData } = req.body;
    transData.date = new Date(transData.date);
    const newTransaction = { ...transData, accountId: new ObjectId(accountId), userId: new ObjectId(req.userId) };
    const result = await db.collection('bankTransactions').insertOne(newTransaction);
    res.status(201).json({ _id: result.insertedId, ...newTransaction });
});
app.post('/api/transactions/upload', async (req, res) => {
    console.log("hey fond the upload file ");
    const { csv, accountId } = req.body;
    console.log("hey fond the upload file ");
    if (!csv || !accountId) {
        return res.status(400).json({ message: 'CSV data and accountId are required.' });
    }
    
    try {
        const parsedData = await parseTSV(csv);
	    console.log("thee data heere is after parsing : " + JSON.stringify(parsedData));

        const newTransactions = parsedData.map(row => ({
            date: new Date(row.date),
            details: row.description,
            debit: parseFloat(row.debit) || 0,
            credit: parseFloat(row.credit) || 0,
            balance: parseFloat(row.balance) || 0,
            source: 'CSV',
            accountId: new ObjectId(accountId),
            userId: new ObjectId(req.userId),
        })).filter(t => !isNaN(t.date.getTime()) && t.details);

    	console.log("it didn't went any where it here" + newTransactions);
        if (newTransactions.length === 0) {
    		console.log("hey fond the upload file it the error log " + newTransactions);
            return res.status(400).json({ message: 'No valid transactions found in CSV.' });
        }

        const datesInCSV = [...new Set(newTransactions.map(t => t.date.toISOString().split('T')[0]))];
        const dateClauses = datesInCSV.map((isoDate) => {
            const startOfDay = new Date(isoDate);
            startOfDay.setUTCHours(0, 0, 0, 0);
            const endOfDay = new Date(startOfDay);
            endOfDay.setDate(endOfDay.getDate() + 1);
            return { date: { $gte: startOfDay, $lt: endOfDay } };
        });
        
        let deletedResult = { deletedCount: 0 };
        if(dateClauses.length > 0) {
            deletedResult = await db.collection('bankTransactions').deleteMany({ 
                accountId: new ObjectId(accountId), 
                userId: new ObjectId(req.userId), 
                source: 'CSV', 
                $or: dateClauses 
            });
        }
        
        const insertResult = await db.collection('bankTransactions').insertMany(newTransactions);

        res.status(201).json({ 
            insertedCount: insertResult.insertedCount, 
            deletedCount: deletedResult.deletedCount 
        });

    } catch (error) {
        console.error("Error processing bank transactions CSV upload:", error);
        res.status(500).json({ message: 'Server error during CSV processing.' });
    }
});
app.put('/api/transactions/:id', async (req, res) => {
    const { id } = req.params;
    const { _id, userId, accountId, ...updateData } = req.body;
    updateData.date = new Date(updateData.date);
    const result = await db.collection('bankTransactions').updateOne({ _id: new ObjectId(id), userId: new ObjectId(req.userId) }, { $set: updateData });
    if(result.matchedCount === 0) return res.status(404).json({ message: 'Transaction not found.'});
    res.status(200).json({ _id: id, ...updateData });
});
app.delete('/api/transactions/:id', async (req, res) => {
    const result = await db.collection('bankTransactions').deleteOne({ _id: new ObjectId(req.params.id), userId: new ObjectId(req.userId) });
    if(result.deletedCount === 0) return res.status(404).json({ message: 'Transaction not found.'});
    res.status(204).send();
});
app.post('/api/transactions/delete-by-date', async (req, res) => {
    const { accountId, dates } = req.body;
    const dateClauses = dates.map((isoDate) => {
        const startOfDay = new Date(isoDate);
        startOfDay.setUTCHours(0, 0, 0, 0);
        const endOfDay = new Date(startOfDay);
        endOfDay.setDate(endOfDay.getDate() + 1);
        return { date: { $gte: startOfDay, $lt: endOfDay } };
    });
    const result = await db.collection('bankTransactions').deleteMany({ accountId: new ObjectId(accountId), userId: new ObjectId(req.userId), source: 'CSV', $or: dateClauses });
    res.status(200).json({ success: true, deletedCount: result.deletedCount });
});
app.post('/api/transactions/bulk', async (req, res) => {
    const transactions = req.body;
    const userId = new ObjectId(req.userId);
    const newTransactions = transactions.map(t => ({ ...t, date: new Date(t.date), accountId: new ObjectId(t.accountId), userId }));
    const result = await db.collection('bankTransactions').insertMany(newTransactions);
    res.status(201).json({ insertedCount: result.insertedCount });
});
app.post('/api/transactions/bulk-delete', async (req, res) => {
    const { ids } = req.body;
    const objectIds = ids.map((id) => new ObjectId(id));
    const result = await db.collection('bankTransactions').deleteMany({ _id: { $in: objectIds }, userId: new ObjectId(req.userId) });
    res.status(200).json({ success: true, deletedCount: result.deletedCount });
});

// === INVESTMENTS ROUTES (Placeholder) ===
app.get('/api/investments', authMiddleware, (req, res) => res.status(501).json({ message: 'Not Implemented' }));
app.post('/api/investments', authMiddleware, (req, res) => res.status(501).json({ message: 'Not Implemented' }));

// --- START SERVER ---
connectToDatabase().then(() => {
    app.listen(PORT, () => {
        console.log(`Backend server running on http://localhost:${PORT}`);
    });
});

module.exports = app;
    
